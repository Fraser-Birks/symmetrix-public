#include <algorithm>
#include <numeric>
#include <cstdint>
#include <iostream>

#include "tools.hpp"

int _binomial_coefficient(int n, int k)
{
    if (k<0 || k>n) {
        return 0;
    } else if (k==0 || k==n) {
        return 1;
    } else {
        return _binomial_coefficient(n-1,k-1) + _binomial_coefficient(n-1,k);
    }
}

int _sum(std::vector<int> v)
{
    return std::reduce(v.begin(), v.end());
}

std::vector<std::vector<std::vector<int>>> _partitions(std::vector<int> v)
{
    if (v.size() == 0)
        return std::vector<std::vector<std::vector<int>>>();

    std::vector<std::vector<std::vector<int>>> partitions;
    partitions = {{ {{ {v[0]} }} }};
    for (int i=1; i<v.size(); ++i) {

        auto prev_partitions = partitions;

        partitions = std::vector<std::vector<std::vector<int>>>();
        for (auto prev_partition : prev_partitions) {

            // new partition in form of {prev_partition, {v[i]}}
            partitions.push_back(prev_partition);
            partitions[partitions.size()-1].push_back({{ {v[i]} }});

            // new partitions generated by addition v[i] to each prior subset
            for (int j=0; j<prev_partition.size(); ++j) {
                partitions.push_back(prev_partition);
                partitions[partitions.size()-1][j].push_back(v[i]);
            }
        }
    }

//    for (auto &partition : partitions) {
//        std::sort(
//            partition.begin(),
//            partition.end(),
//            [](std::vector<int> i, std::vector<int> j) {
//                return i.size() > j.size();
//            });
//    }

    std::sort(
        partitions.begin(),
        partitions.end(),
        [](std::vector<std::vector<int>> i, std::vector<std::vector<int>> j) {
            return i.size() < j.size();
        });

    return partitions;
}

std::vector<std::vector<std::vector<int>>> _two_part_partitions(std::vector<int> v)
{
    if (v.size() == 0)
        return std::vector<std::vector<std::vector<int>>>();

    auto partitions = std::vector<std::vector<std::vector<int>>>{{{v[0]}}};

    for (int i=1; i<v.size(); ++i) {

        auto prev_partitions = partitions;

        partitions = std::vector<std::vector<std::vector<int>>>();
        for (auto prev_partition : prev_partitions) {

            // new partition in form of {prev_partition, {v[i]}}
            if (prev_partition.size() == 1) {
                partitions.push_back(prev_partition);
                partitions[partitions.size()-1].push_back({{ {v[i]} }});
            }

            // new partitions generated by addition v[i] to each prior subset
            if (prev_partition.size() <= 2) {
                for (int j=0; j<prev_partition.size(); ++j) {
                    partitions.push_back(prev_partition);
                    partitions[partitions.size()-1][j].push_back(v[i]);
                }
            }
        }
    }

    std::erase_if(partitions, [](std::vector<std::vector<int>> p) { return p.size() == 1; });

    std::sort(
        partitions.begin(),
        partitions.end(),
        [](const std::vector<std::vector<int>>& i,
           const std::vector<std::vector<int>>& j) {
            return i.size() < j.size();
        });
    return partitions;
}

std::vector<std::vector<int>> _permutations(int size)
{
    auto v = std::vector<int>(size);
    for (int i=0; i<size; ++i)
        v[i] = i;
    std::vector<std::vector<int>> permutations = {v};
    while (std::next_permutation(v.begin(), v.end()))
        permutations.push_back(v);
    return permutations;
}

std::vector<std::vector<int>> _combinations(std::vector<int> set, int k) {
    if (k != 2)
        throw std::invalid_argument("_combinations: only k=2 is implemented.");
    std::vector<std::vector<int>> combinations;
    for (int i=0; i<set.size(); ++i)
        for (int j=i+1; j<set.size(); ++j)
            combinations.push_back({set[i], set[j]});
    return combinations;
}

std::vector<std::vector<int>> _product_repeat(std::vector<int> input, int repeat) {
    auto inputs = std::vector<std::vector<int>>();
    for (int i=0; i<repeat; ++i)
        inputs.push_back(input);
    return _product(inputs);
}

std::vector<std::vector<int>> _generate_indices(int dim, int max) {
    auto inputs_to_prod = std::vector<std::vector<int>>();
    auto indices = std::vector<int>(max);
    for (int i=0; i<max; ++i)
        indices[i] = i;
    for (int r=0; r<dim; ++r)
        inputs_to_prod.push_back(indices);
    return _product(inputs_to_prod);
}